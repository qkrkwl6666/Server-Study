# Junie 가이드라인 - 게임 서버 프로젝트 코드 설명

## 목적
이 가이드라인은 Junie가 게임 서버 프로젝트의 코드에 대해 질문을 받았을 때, 효과적이고 이해하기 쉬운 설명을 제공하기 위한 지침서입니다.

## 기본 원칙

### 1. 코드 설명 접근법
- **동작 원리 중심**: 코드가 "무엇을" 하는지보다 "어떻게" 동작하는지에 초점을 맞춤
- **계층적 설명**: 전체적인 구조부터 세부 구현까지 단계적으로 설명
- **실제 예시 활용**: 프로젝트의 실제 코드를 예시로 사용

### 2. 설명 구조
모든 코드 설명은 다음 구조를 따릅니다:

```
1. 개요 (Overview)
2. 핵심 구조 (Core Structure)
3. 동작 원리 (How it Works)
4. 주요 구성요소 (Key Components)
5. 데이터 흐름 (Data Flow)
6. 예외 처리 및 에러 핸들링 (Error Handling)
7. 성능 및 최적화 고려사항 (Performance Considerations)
```

## 게임 서버 프로젝트별 설명 가이드

### A. 네트워크 및 소켓 관련 코드 설명

**예시: GameServer.cpp의 소켓 초기화**

```cpp
// 예시 코드
WSAData wsaData;
if (::WSAStartup(MAKEWORD(2,2), &wsaData) != 0)
    return 0;

SOCKET listenSocket = ::socket(AF_INET, SOCK_STREAM, 0);
if (listenSocket == INVALID_SOCKET)
    return 0;

u_long on = 1;
if (::ioctlsocket(listenSocket, FIONBIO, &on) == INVALID_SOCKET)
    return 0;
```

**설명 템플릿:**
1. **개요**: "이 코드는 Windows 소켓을 초기화하고 TCP 리스닝 소켓을 생성하는 과정입니다."

2. **핵심 구조**: 
   - WSA 초기화 → 소켓 생성 → 소켓 옵션 설정의 순서적 진행
   - 각 단계에서 오류 검사 수행

3. **동작 원리**:
   - `WSAStartup`: Windows Socket API 초기화, 버전 2.2 요청
   - `socket`: IPv4 TCP 소켓 생성
   - `ioctlsocket`: 논블로킹 모드 설정 (FIONBIO)

4. **주요 구성요소**:
   - `WSAData`: WSA 정보 저장 구조체
   - `listenSocket`: 클라이언트 연결 대기용 소켓
   - `FIONBIO`: 논블로킹 I/O 제어 명령

5. **데이터 흐름**: 
   시스템 → WSA 초기화 → 소켓 핸들 생성 → 소켓 속성 변경

6. **에러 핸들링**: 각 함수 호출 후 즉시 오류 검사 및 프로그램 종료

### B. 멀티스레딩 관련 코드 설명

**예시: ThreadManager 클래스**

```cpp
class ThreadManager
{
public:
    void Launch(function<void(void)> callback);
    void Join();
    static void InitTLS();
private:
    Mutex _lock;
    vector<thread> _threads;
};
```

**설명 템플릿:**
1. **개요**: "ThreadManager는 게임 서버의 워커 스레드들을 생성, 관리, 동기화하는 역할을 합니다."

2. **핵심 구조**: 
   - 스레드 생성/관리용 컨테이너 (`vector<thread>`)
   - 스레드 안전성을 위한 뮤텍스
   - TLS(Thread Local Storage) 관리

3. **동작 원리**:
   - `Launch`: 콜백 함수를 받아 새 스레드에서 실행
   - `Join`: 모든 스레드의 완료를 대기
   - `InitTLS`: 스레드별 지역 저장소 초기화

### C. 메모리 관리 관련 코드 설명

**메모리 할당자, 참조 카운팅 등의 코드에 대해서는:**
1. **메모리 풀링 전략** 설명
2. **참조 카운팅 동작 원리** 설명
3. **메모리 누수 방지 메커니즘** 설명

### D. 동시성 제어 관련 코드 설명

**Lock, DeadLock 처리 등에 대해서는:**
1. **락의 종류와 용도** (SpinLock, Mutex, Reader-Writer Lock)
2. **데드락 탐지 알고리즘** 설명
3. **동시성 자료구조** (ConcurrentQueue, ConcurrentStack) 동작 원리

## 질문 유형별 대응 방식

### 1. "이 코드가 뭐하는거임?" 유형
- **즉답**: 한 문장으로 핵심 기능 설명
- **상세**: 동작 원리를 단계별로 분해하여 설명
- **예시**: 실제 실행 시나리오 제시

### 2. "어떻게 돌아가는거임?" 유형  
- **플로우 차트 방식**: 단계별 실행 순서 설명
- **상태 변화**: 각 단계에서 변수/객체 상태 변화 추적
- **호출 관계**: 함수/메서드 간 호출 관계 설명

### 3. "왜 이렇게 구현했음?" 유형
- **설계 의도**: 해당 방식을 선택한 이유
- **대안 방법**: 다른 구현 방법과의 비교
- **성능상 이점**: 성능/메모리 관점에서의 장점

### 4. "실제 게임에서 어떻게 쓰임?" 유형
- **사용 시나리오**: 실제 게임 상황에서의 사용례
- **클라이언트-서버 상호작용**: 네트워크 통신 맥락에서의 역할
- **확장성**: 대규모 사용자 환경에서의 동작

## 설명 시 주의사항

### DO (해야 할 것)
- ✅ 한국어로 친근하게 설명
- ✅ 복잡한 개념은 간단한 비유 사용
- ✅ 코드의 실행 순서를 명확히 표시
- ✅ 에러 상황과 예외 처리 방법 언급
- ✅ 실제 프로젝트 맥락에서 설명

### DON'T (하지 말아야 할 것)
- ❌ 단순히 함수 이름만 나열
- ❌ 너무 기술적인 용어만 사용
- ❌ 코드의 목적 없이 구문만 설명
- ❌ 성능이나 메모리 고려사항 생략
- ❌ 일반적인 설명으로 끝내기

## 예시 질문과 답변 템플릿

### Q: "listenSocket은 뭘 하는거임? 실제로 클라와 통신할 때 어떻게 동작함?"

### A: 
**개요**: `listenSocket`은 클라이언트의 연결 요청을 기다리는 "문지기" 역할을 하는 소켓입니다.

**동작 원리**:
1. **대기 상태**: 서버가 시작되면 특정 포트에서 클라이언트 연결을 대기
2. **연결 감지**: 클라이언트가 connect() 호출하면 listenSocket이 감지
3. **새 소켓 생성**: accept() 함수로 실제 통신용 새로운 소켓 생성
4. **통신 시작**: 새 소켓으로 데이터 송수신, listenSocket은 계속 대기

**실제 통신 과정**:
```
클라이언트 → [연결 요청] → listenSocket → [accept()] → 통신 소켓 생성
                                     ↓
                                 다른 클라이언트 연결 계속 대기
```

**핵심 포인트**: listenSocket 자체는 데이터를 주고받지 않고, 연결 요청만 처리해서 실제 통신용 소켓을 만들어주는 역할입니다.

---

이 가이드라인을 따라 사용자의 코드 관련 질문에 대해 체계적이고 이해하기 쉬운 설명을 제공하세요.